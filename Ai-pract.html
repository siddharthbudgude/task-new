<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <h1>Slip 1</h1> -->
    Q.1) Python program that demonstrates the hill climbing algorithm to find the maximum of a mathematical function.(For example f(x) = -x^2 + 4x)   [ 10Marks ] 



<!-- slip 2 -->
Q.1) Write a python program to generate Calendar for the given month and year?. [ 10 Marks ] 
==>
import calendar

year = int(input("Enter the year (e.g., 2024): "))
month = int(input("Enter the month (1-12): "))

if 1 <= month <= 12:
    print(calendar.month(year, month))
else:
    print("Invalid month! Please enter a value between 1 and 12.")


Q.2)Write a Python program to implement Depth First Search algorithm. Refer the following graph as an Input for the program.[Initial node=1,Goal node=7].   [ 20 Marks ] 
==>
def dfs(graph, start, goal, visited=set()):
    if start == goal:
        print(f"Goal node {goal} found!")
        return True
    visited.add(start)
    for neighbor in graph[start]:
        if neighbor not in visited and dfs(graph, neighbor, goal, visited):
            return True
    return False

# Graph as adjacency list
graph = {1: [2, 3, 4], 2: [5, 6], 3: [], 4: [7], 5: [], 6: [], 7: []}

# Initial and goal nodes
if not dfs(graph, 1, 7):
    print("Goal node not found.")


    <!-- slip 3 -->
    Q.1) Write a python program to remove punctuations from the given string? .[ 10 marks ]
    ==>
    import string

def remove_punctuation(text):
    return ''.join(char for char in text if char not in string.punctuation)

# Input string
input_text = input("Enter a string: ")

# Remove punctuations
result = remove_punctuation(input_text)

# Output the result
print("String without punctuation:", result)

Q.2) Write a Python program to implement Depth First Search algorithm. Refer the following graph 
as an Input for the program.[Initial node=2,Goal node=7] [ 20 Marks ]
==>
def dfs(graph, start, goal, visited=set()):
    if start == goal:
        print(f"Goal node {goal} found!")
        return True
    visited.add(start)
    for neighbor in graph[start]:
        if neighbor not in visited and dfs(graph, neighbor, goal, visited):
            return True
    return False

# Graph as adjacency list
graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [7], 6: [], 7: []}

# Perform DFS
if not dfs(graph, 2, 7):
    print("Goal node not found.")



    <!-- slip 4 -->
    Q.1)Write a program to implement Hangman game using python. [10 Marks]
    Description:
    Hangman is a classic word-guessing game. The user should guess the word correctly by
    entering alphabets of the user choice. The Program will get input as single alphabet from the
    user and it will matchmaking with the alphabets in the original 
    ==>
    import random

def hangman():
    words = ['python', 'hangman', 'programming', 'challenge', 'developer']
    word = random.choice(words)  # Randomly select a word
    guessed_word = ['_'] * len(word)  # Placeholder for guessed word
    attempts = 6  # Number of allowed wrong guesses
    guessed_letters = set()

    print("Welcome to Hangman!")
    print(f"The word has {len(word)} letters: {' '.join(guessed_word)}")

    while attempts > 0 and '_' in guessed_word:
        guess = input("Enter a single letter: ").lower()

        if len(guess) != 1 or not guess.isalpha():
            print("Invalid input. Please enter a single alphabet.")
            continue

        if guess in guessed_letters:
            print("You already guessed that letter. Try a different one.")
            continue

        guessed_letters.add(guess)

        if guess in word:
            print(f"Good guess! {guess} is in the word.")
            for i, letter in enumerate(word):
                if letter == guess:
                    guessed_word[i] = guess
        else:
            attempts -= 1
            print(f"Wrong guess! You have {attempts} attempts remaining.")

        print("Current word:", ' '.join(guessed_word))

    if '_' not in guessed_word:
        print("Congratulations! You've guessed the word:", word)
    else:
        print("Game over! The word was:", word)

# Run the Hangman game
if __name__ == "__main__":
    hangman()


    Q.2) Write a Python program to implement Breadth First Search algorithm. Refer the following 
graph as an Input for the program.[Initial node=1,Goal node=8] [ 20 Marks ]
==>
from collections import deque

def bfs(graph, start, goal):
    visited = set()           # To keep track of visited nodes
    queue = deque([start])    # Queue for BFS traversal

    while queue:
        node = queue.popleft()
        print(f"Visiting node: {node}")

        if node == goal:
            print(f"Goal node {goal} found!")
            return True

        if node not in visited:
            visited.add(node)
            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)
    
    print("Goal node not found.")
    return False

if __name__ == "__main__":
    # Graph represented as an adjacency list
    graph = {
        1: [2, 3, 4],
        2: [5, 6],
        3: [7],
        4: [],
        5: [],
        6: [8],
        7: [],
        8: []
    }

    # Initial and goal nodes
    initial_node = 1
    goal_node = 8

    print("Starting Breadth First Search...")
    bfs(graph, initial_node, goal_node)


    <!-- slip 5 -->
    Q.1) Write a python program to implement Lemmatization using NLTK [ 10 Marks ]
    ==>
    from nltk.stem import WordNetLemmatizer
from nltk.corpus import wordnet
import nltk

# Download required NLTK resources
nltk.download('wordnet')
nltk.download('omw-1.4')  # For WordNet data
nltk.download('averaged_perceptron_tagger')
nltk.download('punkt')

# Function to convert NLTK POS tags to WordNet POS tags
def get_wordnet_pos(tag):
    if tag.startswith('J'):
        return wordnet.ADJ
    elif tag.startswith('V'):
        return wordnet.VERB
    elif tag.startswith('N'):
        return wordnet.NOUN
    elif tag.startswith('R'):
        return wordnet.ADV
    else:
        return wordnet.NOUN  # Default to noun

def lemmatize_text(text):
    lemmatizer = WordNetLemmatizer()
    words = nltk.word_tokenize(text)  # Tokenize the input text
    pos_tags = nltk.pos_tag(words)    # Get POS tags for each word
    lemmatized_words = [
        lemmatizer.lemmatize(word, get_wordnet_pos(tag)) for word, tag in pos_tags
    ]
    return ' '.join(lemmatized_words)

if __name__ == "__main__":
    # Input text
    text = input("Enter a sentence for lemmatization: ")

    # Perform lemmatization
    result = lemmatize_text(text)

    print("Original Text: ", text)
    print("Lemmatized Text: ", result)


    Q.2) Write a Python program to implement Breadth First Search algorithm. Refer the following 
graph as an Input for the program.[Initial node=1,Goal node=8] [ 20 Marks ]
==>
from collections import deque

def bfs(graph, start, goal):
    visited = set()           # To keep track of visited nodes
    queue = deque([start])    # Queue for BFS traversal

    while queue:
        node = queue.popleft()  # Dequeue the front element
        print(f"Visiting node: {node}")

        # Check if the goal node is found
        if node == goal:
            print(f"Goal node {goal} found!")
            return True

        if node not in visited:
            visited.add(node)
            # Enqueue all the adjacent nodes that have not been visited
            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)
    
    print("Goal node not found.")
    return False

if __name__ == "__main__":
    # Graph represented as an adjacency list
    graph = {
        1: [2, 3, 4],
        2: [5, 6],
        3: [7],
        4: [],
        5: [],
        6: [8],
        7: [],
        8: []
    }

    # Initial and goal nodes
    initial_node = 1
    goal_node = 8

    print("Starting Breadth First Search...")
    bfs(graph, initial_node, goal_node)


   <!-- slip 6 --> 
   Q1)Write a python program to remove stop words for a given passage from a text file using 
   NLTK?
   ==>
   import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize

# Download required NLTK resources
nltk.download('punkt')
nltk.download('stopwords')

def remove_stopwords(text):
    # Tokenize the input text
    words = word_tokenize(text)
    
    # Get the set of stopwords in English
    stop_words = set(stopwords.words('english'))
    
    # Remove stopwords from the tokenized words
    filtered_words = [word for word in words if word.lower() not in stop_words]
    
    # Join the filtered words back into a string
    return ' '.join(filtered_words)

def process_file(file_path):
    # Read the text from the file
    with open(file_path, 'r') as file:
        text = file.read()

    # Remove stopwords from the text
    cleaned_text = remove_stopwords(text)
    
    print("Original Text:\n", text)
    print("\nText After Removing Stop Words:\n", cleaned_text)

if __name__ == "__main__":
    # Specify the path to your text file
    file_path = input("Enter the path to the text file: ")
    
    process_file(file_path)


    Q.2) Write a Python program to implement Breadth First Search algorithm. Refer the following 
graph as an Input for the program.[Initial node=1,Goal node=8]. [20Marks ]
==>
from collections import deque

def bfs(graph, start, goal):
    queue = deque([start])  # Initialize queue with the start node
    visited = set()         # Set to track visited nodes

    while queue:
        node = queue.popleft()  # Dequeue the first element
        print(f"Visiting node: {node}")
        
        if node == goal:
            print(f"Goal node {goal} found!")
            return True

        if node not in visited:
            visited.add(node)
            # Add unvisited neighbors to the queue
            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)
    
    print("Goal node not found.")
    return False

# Graph represented as an adjacency list
graph = {
    1: [2, 3, 4],
    2: [5, 6],
    3: [7],
    4: [],
    5: [],
    6: [8],
    7: [],
    8: []
}

# Perform BFS
bfs(graph, start=1, goal=8)


<!-- slip 7 -->
Q.1)Write a python program implement tic-tac-toe using alpha beeta pruning[10 Marks]
==>
import math

def print_board(board):
    for row in board: print(" | ".join(row)); print("-" * 5)

def check_winner(board):
    lines = board + [list(col) for col in zip(*board)] + [[board[i][i] for i in range(3)], [board[i][2-i] for i in range(3)]]
    return 'X' if ['X'] * 3 in lines else 'O' if ['O'] * 3 in lines else None

def is_full(board): return all(cell != ' ' for row in board for cell in row)

def alpha_beta(board, depth, alpha, beta, maximizing):
    winner = check_winner(board)
    if winner: return 1 if winner == 'X' else -1
    if is_full(board): return 0
    if maximizing:
        max_eval = -math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == ' ':
                    board[i][j] = 'X'
                    max_eval = max(max_eval, alpha_beta(board, depth + 1, alpha, beta, False))
                    board[i][j] = ' '
                    alpha = max(alpha, max_eval)
                    if beta <= alpha: break
        return max_eval
    else:
        min_eval = math.inf
        for i in range(3):
            for j in range(3):
                if board[i][j] == ' ':
                    board[i][j] = 'O'
                    min_eval = min(min_eval, alpha_beta(board, depth + 1, alpha, beta, True))
                    board[i][j] = ' '
                    beta = min(beta, min_eval)
                    if beta <= alpha: break
        return min_eval

def best_move(board):
    best_val, move = -math.inf, (-1, -1)
    for i in range(3):
        for j in range(3):
            if board[i][j] == ' ':
                board[i][j] = 'X'
                move_val = alpha_beta(board, 0, -math.inf, math.inf, False)
                board[i][j] = ' '
                if move_val > best_val: best_val, move = move_val, (i, j)
    return move

def play_tic_tac_toe():
    board = [[' ']*3 for _ in range(3)]
    print("You: O, AI: X"); print_board(board)
    while True:
        r, c = map(int, input("Enter row and column (0-2): ").split())
        if board[r][c] != ' ': print("Invalid move!"); continue
        board[r][c], winner = 'O', check_winner(board)
        if winner or is_full(board): break
        ai_r, ai_c = best_move(board)
        board[ai_r][ai_c] = 'X'
        print_board(board)
        if check_winner(board) or is_full(board): break
    print_board(board)
    print("Winner:", "AI" if winner == 'X' else "You" if winner == 'O' else "Draw")

play_tic_tac_toe()


Q.2) Write a Python program to implement Simple Chatbot. [ 20Marks ]
==>
def chatbot_response(user_input):
    responses = {
        "hello": "Hi there! How can I help you?",
        "hi": "Hello! What can I do for you?",
        "how are you": "I'm just a bot, but I'm doing great! How about you?",
        "what is your name": "I'm ChatBot! What's your name?",
        "bye": "Goodbye! Have a great day!",
        "default": "I'm sorry, I didn't understand that. Can you please rephrase?"
    }

    # Convert input to lowercase for matching
    user_input = user_input.lower()
    
    # Check for a response
    for key in responses:
        if key in user_input:
            return responses[key]
    
    return responses["default"]

def chatbot():
    print("ChatBot: Hello! I am a simple chatbot. Type 'bye' to exit.")
    
    while True:
        user_input = input("You: ")
        if user_input.lower() == "bye":
            print("ChatBot: Goodbye! Take care.")
            break
        response = chatbot_response(user_input)
        print(f"ChatBot: {response}")

# Run the chatbot
chatbot()


<!-- slip 8 -->
Q.1) Write a Python program to accept a string. Find and print the number of upper case alphabets 
and lower case alphabets. [ 10 Marks ]
==>
def count_case(s):
    upper_count = sum(1 for char in s if char.isupper())
    lower_count = sum(1 for char in s if char.islower())
    return upper_count, lower_count

# Input string from the user
input_string = input("Enter a string: ")

# Get counts
upper, lower = count_case(input_string)

# Display the results
print(f"Number of uppercase letters: {upper}")
print(f"Number of lowercase letters: {lower}")



Q.2) Write a Python program to solve tic-tac-toe problem. [ 20 Marks ]
==>
def print_board(board):
    for row in board: print(" | ".join(row)); print("-" * 5)

def check_winner(board):
    lines = board + [list(col) for col in zip(*board)] + [[board[i][i] for i in range(3)], [board[i][2-i] for i in range(3)]]
    for line in lines:
        if line[0] == line[1] == line[2] and line[0] != ' ': return line[0]
    return None

def tic_tac_toe():
    board = [[' '] * 3 for _ in range(3)]
    print("Welcome to Tic-Tac-Toe!\nPlayer 1: X, Player 2: O")
    current_player = 'X'
    
    for turn in range(9):
        print_board(board)
        try:
            r, c = map(int, input(f"Player {current_player}'s turn (row col): ").split())
            if board[r][c] != ' ': raise ValueError("Cell taken!")
        except (ValueError, IndexError):
            print("Invalid move. Try again."); continue
        board[r][c] = current_player
        if check_winner(board): print_board(board); print(f"Player {current_player} wins!"); return
        current_player = 'O' if current_player == 'X' else 'X'
    
    print_board(board)
    print("It's a draw!")

tic_tac_toe()



<!-- slip 9 -->
Q.1) Write python program to solve 8 puzzle problem using A* algorithm [10 marks]
==>
import heapq

# Function to calculate heuristic (Manhattan distance)
def heuristic(state, goal):
    distance = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0:
                x, y = divmod(goal.index(state[i][j]), 3)
                distance += abs(x - i) + abs(y - j)
    return distance

# Function to get the neighbors of a given state
def get_neighbors(state):
    neighbors = []
    x, y = next((i, j) for i, row in enumerate(state) for j, val in enumerate(row) if val == 0)  # Locate the blank
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    return neighbors

# A* algorithm to solve the 8-puzzle
def a_star(start, goal):
    goal_flat = [val for row in goal for val in row]
    open_list = []
    heapq.heappush(open_list, (0, start, []))
    visited = set()
    while open_list:
        cost, current, path = heapq.heappop(open_list)
        current_flat = tuple(val for row in current for val in row)
        if current_flat in visited:
            continue
        visited.add(current_flat)
        if current == goal:
            return path + [current]
        for neighbor in get_neighbors(current):
            heapq.heappush(open_list, (cost + 1 + heuristic(neighbor, goal_flat), neighbor, path + [current]))
    return None

# Print the board state
def print_board(state):
    for row in state:
        print(" ".join(str(x) if x != 0 else " " for x in row))
    print()

# Main Function
if __name__ == "__main__":
    start_state = [[1, 2, 3], [4, 0, 6], [7, 5, 8]]  # Initial state
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]   # Goal state

    print("Start State:")
    print_board(start_state)
    print("Goal State:")
    print_board(goal_state)

    print("Solving...")
    solution = a_star(start_state, goal_state)
    if solution:
        for i, step in enumerate(solution):
            print(f"Step {i}:")
            print_board(step)
    else:
        print("No solution found!")


Q.2) Write a Python program to solve water jug problem. 2 jugs with capacity 5 gallon and 7 gallon 
are given with unlimited water supply respectively. The target to achieve is 4 gallon of water in 
second jug. [ 15 Marks ]
==>
from collections import deque

def water_jug_solver():
    # Initialize capacities and goal
    capacity = (5, 7)  # Jug capacities: (jug1, jug2)
    target = (0, 4)    # Target state: 4 gallons in the second jug
    visited = set()
    queue = deque([(0, 0)])  # Start with both jugs empty
    path = {}

    def valid_moves(state):
        jug1, jug2 = state
        moves = [
            (capacity[0], jug2),  # Fill jug1
            (jug1, capacity[1]),  # Fill jug2
            (0, jug2),            # Empty jug1
            (jug1, 0),            # Empty jug2
            (max(jug1 + jug2 - capacity[1], 0), min(jug1 + jug2, capacity[1])),  # Pour jug1 -> jug2
            (min(jug1 + jug2, capacity[0]), max(jug1 + jug2 - capacity[0], 0)),  # Pour jug2 -> jug1
        ]
        return [move for move in moves if move not in visited]

    while queue:
        current = queue.popleft()
        visited.add(current)

        if current == target:
            # Trace back the path
            result_path = []
            while current:
                result_path.append(current)
                current = path.get(current)
            return result_path[::-1]

        for move in valid_moves(current):
            path[move] = current
            queue.append(move)

    return None

# Run the solver
solution = water_jug_solver()
if solution:
    print("Solution steps:")
    for step in solution:
        print(f"Jug1: {step[0]} gallons, Jug2: {step[1]} gallons")
else:
    print("No solution found.")


    <!-- slip 10 -->
    Q.1) Write Python program to implement crypt arithmetic problem 
    TWO+TWO=FOUR
    ==>
    from itertools import permutations

    def solve_cryptarithmetic():
        # Define the unique letters in the equation
        letters = 'TWOFUR'
        # Digits (0-9) for each letter
        for perm in permutations(range(10), len(letters)):
            mapping = dict(zip(letters, perm))
            # Ensure 'T' and 'F' are not zero (no leading zeros)
            if mapping['T'] == 0 or mapping['F'] == 0:
                continue
            
            # Map letters to the numbers
            TWO = mapping['T'] * 100 + mapping['W'] * 10 + mapping['O']
            FOUR = mapping['F'] * 1000 + mapping['O'] * 100 + mapping['U'] * 10 + mapping['R']
    
            # Check if the equation holds
            if TWO + TWO == FOUR:
                print("Solution found:")
                print(f"TWO = {TWO}, FOUR = {FOUR}")
                print(f"Mapping: {mapping}")
                return
    
        print("No solution found.")
    
    # Run the solver
    solve_cryptarithmetic()

    Q.2) Write a Python program to implement Simple Chatbot. [ 20 Marks ]
    ==>
    import random

# Define responses for the chatbot
responses = {
    "hello": ["Hi!", "Hello!", "Hey there!"],
    "how are you": ["I'm doing great, thank you!", "I'm just a bot, but I'm good!", "I'm fine, how about you?"],
    "bye": ["Goodbye!", "See you later!", "Take care!"],
    "default": ["Sorry, I didn't understand that.", "Could you please rephrase?", "I'm not sure what you mean."]
}

def chatbot_response(user_input):
    # Convert the input to lowercase to match the responses
    user_input = user_input.lower()

    # Check for known responses
    if user_input in responses:
        return random.choice(responses[user_input])
    else:
        return random.choice(responses["default"])

def chatbot():
    print("Chatbot: Hello! Type 'bye' to end the conversation.")
    
    while True:
        user_input = input("You: ")
        
        # If the user says 'bye', end the conversation
        if user_input.lower() == "bye":
            print("Chatbot:", random.choice(responses["bye"]))
            break
        
        # Get and print the chatbot's response
        response = chatbot_response(user_input)
        print("Chatbot:", response)

# Start the chatbot
chatbot()


<!-- slip 11 -->
Q.1) Write a python program using mean end analysis algorithmproblem of transforming a string of 
lowercase letters into another string. [ 10 Marks ]
==>
def mean_end_analysis(start, goal):
    # Step count to track the transformation steps
    steps = []
    
    # Convert start string and goal string to list for easier manipulation
    current_state = list(start)
    goal_state = list(goal)

    # While the current string is not equal to the goal
    while current_state != goal_state:
        # Identify the position where the current state differs from the goal state
        for i in range(len(current_state)):
            if current_state[i] != goal_state[i]:
                # Apply an action to reduce the difference at position i
                current_state[i] = goal_state[i]
                # Record the step
                steps.append(''.join(current_state))
                break  # Proceed to next difference

    return steps

# Main function to run the program
if __name__ == "__main__":
    start_string = "abcdef"
    goal_string = "azcdef"
    
    # Call the Mean-End Analysis function
    steps = mean_end_analysis(start_string, goal_string)
    
    # Display the steps to transform the string
    print("Steps to transform '{}' into '{}':".format(start_string, goal_string))
    for step in steps:
        print(step)

        Q.2) Write a Python program to solve water jug problem. Two jugs with capacity 4 gallon and 3 
        gallon are given with unlimited water supply respectively. The target is to achieve 2 gallon of 
        water in second jug. [ 20 Marks ]
        ==>
        from collections import deque

# Function to find the solution to the water jug problem using BFS
def water_jug_solver(capacity1, capacity2, target):
    # Initial state (both jugs are empty)
    start = (0, 0)
    
    # Queue for BFS and a set to track visited states
    queue = deque([(start, [])])  # (current state, steps taken)
    visited = set([start])
    
    while queue:
        (jug1, jug2), path = queue.popleft()
        
        # If we've reached the goal state
        if jug2 == target:
            print("Solution found:")
            for step in path + [(jug1, jug2)]:
                print(f"Jug1: {step[0]} gallons, Jug2: {step[1]} gallons")
            return
        
        # Generate possible next states
        next_states = [
            (capacity1, jug2),  # Fill Jug 1
            (jug1, capacity2),  # Fill Jug 2
            (0, jug2),          # Empty Jug 1
            (jug1, 0),          # Empty Jug 2
            (max(jug1 - (capacity2 - jug2), 0), min(jug2 + jug1, capacity2)),  # Pour Jug 1 into Jug 2
            (min(jug1 + jug2, capacity1), max(jug2 - (capacity1 - jug1), 0))   # Pour Jug 2 into Jug 1
        ]
        
        for next_state in next_states:
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, path + [(jug1, jug2)]))
    
    print("No solution found.")
    
# Define the capacities of the two jugs and the target amount
capacity1 = 4  # Capacity of Jug 1
capacity2 = 3  # Capacity of Jug 2
target = 2     # Target amount in Jug 2

# Call the function to solve the problem
water_jug_solver(capacity1, capacity2, target)



<!-- slip 12 -->
Q.1) Write a python program to generate Calendar for the given month and year?. [ 10Marks ]
==>
import calendar

def generate_calendar(year, month):
    # Use the calendar module to print the calendar for the given year and month
    cal = calendar.month(year, month)
    print(cal)

# Get user input for year and month
year = int(input("Enter the year (e.g. 2024): "))
month = int(input("Enter the month (1-12): "))

# Generate and print the calendar
generate_calendar(year, month)

Q.2)Write a Python program to simulate 4-Queens problem. [ 20Marks ]
==>
def is_safe(board, row, col):
    # Check the column
    for i in range(row):
        if board[i] == col or \
           board[i] - i == col - row or \
           board[i] + i == col + row:
            return False
    return True

def solve_queens(board, row):
    # If all queens are placed, print the solution
    if row == len(board):
        print_board(board)
        return True

    res = False
    for col in range(len(board)):
        if is_safe(board, row, col):
            board[row] = col  # Place the queen
            res = solve_queens(board, row + 1) or res  # Recur to place the rest
            board[row] = -1  # Backtrack if placing queen doesn't lead to a solution
    return res

def print_board(board):
    for row in range(len(board)):
        line = ['Q' if col == board[row] else '.' for col in range(len(board))]
        print(" ".join(line))
    print()

def solve_4_queens():
    n = 4  # 4x4 chessboard
    board = [-1] * n  # Initialize board with -1 (no queens placed)
    if not solve_queens(board, 0):
        print("Solution does not exist.")
    else:
        print("Solutions found.")

# Run the 4-Queens solver
solve_4_queens()


<!-- slip 13 -->
Q.1Write a Python program to implement Mini-Max Algorithm. [ 10 Marks ]
==>
import math

PLAYER_X, PLAYER_O, EMPTY = "X", "O", "."

def evaluate(board):
    for i in range(3):
        if board[i][0] == board[i][1] == board[i][2]:
            return 10 if board[i][0] == PLAYER_X else -10
        if board[0][i] == board[1][i] == board[2][i]:
            return 10 if board[0][i] == PLAYER_X else -10
    if board[0][0] == board[1][1] == board[2][2]:
        return 10 if board[0][0] == PLAYER_X else -10
    if board[0][2] == board[1][1] == board[2][0]:
        return 10 if board[0][2] == PLAYER_X else -10
    return 0

def is_board_full(board):
    return all(board[i][j] != EMPTY for i in range(3) for j in range(3))

def minimax(board, depth, is_max):
    score = evaluate(board)
    if score != 0: return score
    if is_board_full(board): return 0

    best = -math.inf if is_max else math.inf
    for i in range(3):
        for j in range(3):
            if board[i][j] == EMPTY:
                board[i][j] = PLAYER_X if is_max else PLAYER_O
                best = max(best, minimax(board, depth + 1, not is_max)) if is_max else min(best, minimax(board, depth + 1, not is_max))
                board[i][j] = EMPTY
    return best

def find_best_move(board):
    best_val, best_move = -math.inf, (-1, -1)
    for i in range(3):
        for j in range(3):
            if board[i][j] == EMPTY:
                board[i][j] = PLAYER_X
                move_val = minimax(board, 0, False)
                board[i][j] = EMPTY
                if move_val > best_val:
                    best_move, best_val = (i, j), move_val
    return best_move

def print_board(board):
    for row in board:
        print(" ".join(row))
    print()

def play_game():
    board = [[EMPTY for _ in range(3)] for _ in range(3)]
    while True:
        print_board(board)
        move = find_best_move(board)
        board[move[0]][move[1]] = PLAYER_X
        if evaluate(board) == 10:
            print_board(board)
            print("Player X wins!")
            break
        if is_board_full(board):
            print_board(board)
            print("It's a tie!")
            break
        print_board(board)
        move = find_best_move(board)
        board[move[0]][move[1]] = PLAYER_O
        if evaluate(board) == -10:
            print_board(board)
            print("Player O wins!")
            break
        if is_board_full(board):
            print_board(board)
            print("It's a tie!")
            break

play_game()

Q.2) Write a Python program to simulate 8-Queens problem. [ 20 Marks ]
==>
N = 8  # Size of the chessboard

# Function to check if a queen can be placed at board[row][col]
def is_safe(board, row, col):
    # Check column
    for i in range(row):
        if board[i] == col or abs(board[i] - col) == row - i:
            return False
    return True

# Function to solve the 8-Queens problem using backtracking
def solve_queens(board, row):
    if row == N:  # All queens are placed
        print_board(board)
        return True

    for col in range(N):
        if is_safe(board, row, col):
            board[row] = col  # Place the queen
            if solve_queens(board, row + 1):  # Recur for the next row
                return True
            board[row] = -1  # Backtrack if placement doesn't lead to a solution
    return False

# Function to print the chessboard with queens
def print_board(board):
    for row in range(N):
        row_str = ""
        for col in range(N):
            if board[row] == col:
                row_str += "Q "
            else:
                row_str += ". "
        print(row_str)
    print()

# Main function to start solving the 8-Queens problem
def main():
    board = [-1] * N  # Initialize the board, -1 indicates no queen in that row
    if not solve_queens(board, 0):
        print("Solution does not exist")

# Run the program
main()


<!-- slip 14 -->
Q.1) Write a python program to sort the sentence in alphabetical order?
[ 10Marks ]
==>
def sort_sentence(sentence):
    # Split the sentence into words
    words = sentence.split()
    # Sort the words alphabetically
    words.sort()
    # Join the sorted words back into a sentence
    return ' '.join(words)

# Input sentence
sentence = input("Enter a sentence: ")

# Sort the sentence and print the result
sorted_sentence = sort_sentence(sentence)
print("Sorted sentence:", sorted_sentence)

Q.2) Write a Python program to simulate n-Queens problem. [ 20Marks ]
==>
def is_safe(board, row, col, n):
    return all(board[i] != col and abs(board[i] - col) != row - i for i in range(row))

def solve_nqueens(board, row, n):
    if row == n:
        for i in range(n):
            print('. ' * board[i] + 'Q ' + '. ' * (n - board[i] - 1))
        print()
        return True

    for col in range(n):
        if is_safe(board, row, col, n):
            board[row] = col
            if solve_nqueens(board, row + 1, n):
                return True
            board[row] = -1
    return False

def n_queens(n):
    board = [-1] * n
    if not solve_nqueens(board, 0, n):
        print("Solution does not exist")

n = int(input("Enter the value of n: "))
n_queens(n)


<!-- slip 15 -->
Q.1)Write a Program to Implement Monkey Banana Problem using Python [ 10 Marks ]
==>
class MonkeyBanana:
    def __init__(self):
        self.monkey_position = 0  # 0: ground, 1: on box
        self.box_position = 0     # 0: on ground, 1: under banana
        self.banana_position = 1  # 1: hanging, 0: in hand

    def move(self):
        if self.monkey_position == 0: print("Monkey moves to box.")
        if self.box_position == 0: print("Monkey moves box under banana.")
        print("Monkey climbs box to get banana.")
        self.banana_position = 0

    def get_banana(self):
        print("Monkey got the banana!" if self.banana_position == 0 else "Monkey failed.")

def solve():
    problem = MonkeyBanana()
    problem.move()
    problem.get_banana()

solve()

Q.2) Write a program to implement Iterative Deepening DFS algorithm. [20 Marks ]
[ Goal Node =G]
==>
class IterativeDeepeningDFS:
    def __init__(self, graph, goal):
        self.graph = graph
        self.goal = goal

    # Depth-Limited DFS
    def dfs(self, node, depth, visited):
        if depth == 0:
            if node == self.goal:
                print(f"Goal {self.goal} found!")
                return True
            return False
        if depth > 0:
            visited.add(node)
            for neighbor in self.graph.get(node, []):
                if neighbor not in visited:
                    if self.dfs(neighbor, depth - 1, visited):
                        return True
            visited.remove(node)
        return False

    # Iterative Deepening DFS
    def iddfs(self, start):
        depth = 0
        while True:
            visited = set()
            print(f"Depth: {depth}")
            if self.dfs(start, depth, visited):
                return
            depth += 1
        print("Goal not found.")

# Define the graph (Adjacency List)
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F', 'G'],
    'D': ['B'],
    'E': ['B'],
    'F': ['C'],
    'G': ['C']
}

# Goal node
goal = 'G'

# Create the IDDFS object
iddfs = IterativeDeepeningDFS(graph, goal)

# Start the search from node 'A'
iddfs.iddfs('A')


<!-- slip 16 -->
Q.1) Write a Program to Implement Tower of Hanoi using Python [ 10 Marks ]
==>
def tower_of_hanoi(n, source, target, auxiliary):
    if n == 1:
        print(f"Move disk 1 from {source} to {target}")
        return
    # Move n-1 disks from source to auxiliary peg
    tower_of_hanoi(n-1, source, auxiliary, target)
    # Move the nth disk from source to target peg
    print(f"Move disk {n} from {source} to {target}")
    # Move n-1 disks from auxiliary peg to target peg
    tower_of_hanoi(n-1, auxiliary, target, source)

# Driver code
n = int(input("Enter the number of disks: "))
tower_of_hanoi(n, 'A', 'C', 'B')  # A, B, and C are the names of the pegs

Q.2) Write a Python program to solve tic-tac-toe problem. [ 15 Marks ]
==>
# Function to initialize the board
def initialize_board():
    return [[' ' for _ in range(3)] for _ in range(3)]

# Function to print the board
def print_board(board):
    print("-----------")
    for row in board:
        print("|", " | ".join(row), "|")
        print("-----------")

# Function to check for a winner
def check_winner(board, player):
    # Check rows, columns, and diagonals
    for i in range(3):
        if all([board[i][j] == player for j in range(3)]) or all([board[j][i] == player for j in range(3)]):
            return True
    if board[0][0] == board[1][1] == board[2][2] == player or board[0][2] == board[1][1] == board[2][0] == player:
        return True
    return False

# Function to check if the board is full
def is_board_full(board):
    return all([board[i][j] != ' ' for i in range(3) for j in range(3)])

# Function to take player's move
def player_move(board, player):
    while True:
        try:
            move = int(input(f"Player {player}, enter your move (1-9): ")) - 1
            row, col = move // 3, move % 3
            if board[row][col] == ' ':
                board[row][col] = player
                break
            else:
                print("Cell already taken, choose another one.")
        except (ValueError, IndexError):
            print("Invalid move, try again with a number between 1 and 9.")

# Main function to run the game
def tic_tac_toe():
    board = initialize_board()
    current_player = 'X'
    
    print_board(board)
    
    while True:
        player_move(board, current_player)
        print_board(board)
        
        if check_winner(board, current_player):
            print(f"Player {current_player} wins!")
            break
        if is_board_full(board):
            print("It's a draw!")
            break
        
        # Switch to the other player
        current_player = 'O' if current_player == 'X' else 'X'

# Run the game
tic_tac_toe()


<!-- slip 17 -->
Q.1) Python program that demonstrates the hill climbing algorithm to find the maximum of a 
mathematical function. [ 10Marks ]
==>
import random

def hill_climbing(func, start, step_size, max_iterations, lower_bound, upper_bound):
    current_point = start
    current_value = func(current_point)

    for _ in range(max_iterations):
        # Generate a new candidate by adding or subtracting the step size
        neighbors = [current_point + step_size, current_point - step_size]
        # Keep neighbors within bounds
        neighbors = [x for x in neighbors if lower_bound <= x <= upper_bound]
        
        # Evaluate the neighbors
        neighbor_values = [func(x) for x in neighbors]
        
        # Find the best neighbor
        max_value = max(neighbor_values, default=current_value)
        max_index = neighbor_values.index(max_value) if neighbor_values else -1
        
        if max_value > current_value:
            current_point = neighbors[max_index]
            current_value = max_value
        else:
            # No improvement; terminate early
            break

    return current_point, current_value

# Example function to maximize: f(x) = -x^2 + 4x + 6
def example_function(x):
    return -x**2 + 4*x + 6

# Parameters
start = random.uniform(-10, 10)  # Random start point
step_size = 0.1
max_iterations = 100
lower_bound = -10  # x >= -10
upper_bound = 10   # x <= 10

# Run the Hill Climbing algorithm
optimal_point, optimal_value = hill_climbing(
    func=example_function,
    start=start,
    step_size=step_size,
    max_iterations=max_iterations,
    lower_bound=lower_bound,
    upper_bound=upper_bound
)

print(f"Optimal Point: {optimal_point}")
print(f"Optimal Value: {optimal_value}")

Q.2) Write a Python program to implement A* algorithm. Refer the following graph as an Input for 
the program.[ Start vertex is A and Goal Vertex is G] [ 20 Marks ]
==>
from queue import PriorityQueue

# A* Algorithm
def a_star_algorithm(graph, heuristics, start, goal):
    # Priority queue to store (cost, current_node, path)
    open_list = PriorityQueue()
    open_list.put((0 + heuristics[start], start, [start]))
    closed_list = set()
    
    while not open_list.empty():
        current_cost, current_node, path = open_list.get()
        
        if current_node in closed_list:
            continue
        closed_list.add(current_node)
        
        # If goal is reached, return the path and cost
        if current_node == goal:
            return path, current_cost - heuristics[goal]
        
        # Explore neighbors
        for neighbor, weight in graph[current_node]:
            if neighbor not in closed_list:
                g_cost = current_cost - heuristics[current_node] + weight
                f_cost = g_cost + heuristics[neighbor]
                open_list.put((f_cost, neighbor, path + [neighbor]))
    
    return None, float('inf')

# Input Graph (Adjacency List with weights)
graph = {
    'A': [('B', 1), ('C', 3)],
    'B': [('D', 3), ('E', 1)],
    'C': [('F', 2)],
    'D': [('G', 4)],
    'E': [('G', 2)],
    'F': [('G', 5)],
    'G': []
}

# Heuristic values (h(n)) for each node
heuristics = {
    'A': 7,
    'B': 6,
    'C': 5,
    'D': 5,
    'E': 3,
    'F': 6,
    'G': 0
}

# Run A* Algorithm
start = 'A'
goal = 'G'
path, cost = a_star_algorithm(graph, heuristics, start, goal)

# Output the result
if path:
    print(f"Path: {' -> '.join(path)}")
    print(f"Cost: {cost}")
else:
    print("No path found.")



</body>
</html>